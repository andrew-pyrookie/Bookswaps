# Generated by Django 5.2 on 2025-04-28 18:22

import backend.swaps.models
import django.core.validators
import django.db.models.deletion
import uuid
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('library', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Share',
            fields=[
                ('share_id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('content_type', models.CharField(choices=[('book', 'Book'), ('discussion', 'Discussion'), ('profile', 'Profile'), ('swap', 'Swap'), ('society', 'Society')], db_comment='Type of content being shared', max_length=20)),
                ('content_id', models.UUIDField(db_comment='UUID of the shared content')),
                ('destination', models.CharField(choices=[('x', 'X'), ('facebook', 'Facebook'), ('linkedin', 'LinkedIn'), ('external', 'External Link'), ('email', 'Email')], db_comment='Where the content is shared', max_length=50)),
                ('platform', models.CharField(blank=True, choices=[('web', 'Web'), ('mobile', 'Mobile'), ('api', 'API')], db_comment='Platform that initiated the share', max_length=20, null=True)),
                ('status', models.CharField(choices=[('pending', 'Pending'), ('success', 'Success'), ('failed', 'Failed')], db_comment='Status of the share attempt', default='pending', max_length=20)),
                ('is_reshare', models.BooleanField(db_comment='Marks whether a share is original or repeated', default=False)),
                ('metadata', models.JSONField(blank=True, db_comment='Sharing metadata (e.g., {"url": "https://x.com/...", "text": "Swapped a book!"})', null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True, db_comment='When share was created')),
            ],
            options={
                'db_table': 'shares',
                'db_table_comment': 'Tracks sharing of content for visibility analysis',
            },
        ),
        migrations.CreateModel(
            name='Swap',
            fields=[
                ('swap_id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('status', models.CharField(choices=[('Requested', 'Requested'), ('Accepted', 'Accepted'), ('Confirmed', 'Confirmed'), ('Completed', 'Completed'), ('Cancelled', 'Cancelled')], db_comment='Current status of the swap', default='Requested', max_length=20)),
                ('meetup_time', models.DateTimeField(blank=True, db_comment='Scheduled meetup time', null=True)),
                ('locked_until', models.DateTimeField(blank=True, db_comment='Time until swap is locked (e.g., pending confirmation)', null=True)),
                ('qr_code_url', models.URLField(blank=True, db_comment='S3 URL for QR code used in swap confirmation', max_length=500, null=True, unique=True)),
                ('created_at', models.DateTimeField(auto_now_add=True, db_comment='When swap was created')),
                ('updated_at', models.DateTimeField(auto_now=True, db_comment='When swap was last updated')),
            ],
            options={
                'db_table': 'swaps',
                'db_table_comment': 'Manages book swaps between users',
            },
        ),
        migrations.CreateModel(
            name='Location',
            fields=[
                ('location_id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('name', models.CharField(db_comment='Name of the location (e.g., Central Library)', max_length=255)),
                ('type', models.CharField(choices=[('library', 'Library'), ('cafe', 'Cafe'), ('bookstore', 'Bookstore'), ('park', 'Park'), ('other', 'Other')], db_comment='Type of exchange spot', max_length=50)),
                ('coords', models.JSONField(db_comment='Geo-coordinates for midpoint calculation and scan verification (e.g., {"latitude": 41.8781, "longitude": -87.6298})', validators=[backend.swaps.models.validate_coords])),
                ('city', models.CharField(db_comment='City of the location', max_length=100)),
                ('rating', models.FloatField(blank=True, db_comment='User or source rating (0-5)', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(5)])),
                ('last_fetched', models.DateTimeField(blank=True, db_comment='When data was last updated from source', null=True)),
                ('source', models.CharField(blank=True, db_comment='Data source (e.g., Google Maps, OSM)', max_length=50, null=True)),
                ('verified', models.BooleanField(db_comment='True if location is human-vetted', default=False)),
                ('popularity_score', models.FloatField(blank=True, db_comment='Ranking metric based on usage and rating (e.g., rating * usage_count)', null=True)),
                ('is_active', models.BooleanField(db_comment='True if location is available for swaps', default=True)),
            ],
            options={
                'db_table': 'locations',
                'db_table_comment': 'Caches public exchange spots with coordinates and ratings for swap logic',
                'indexes': [models.Index(fields=['city'], name='locations_city_278550_idx'), models.Index(fields=['type', 'is_active'], name='locations_type_65f522_idx'), models.Index(fields=['popularity_score'], name='locations_popular_bb7f29_idx')],
                'unique_together': {('name', 'city')},
            },
        ),
        migrations.CreateModel(
            name='Exchange',
            fields=[
                ('exchange_id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('exchange_date', models.DateTimeField(db_comment='When the physical exchange occurred')),
                ('initiator_confirmed', models.BooleanField(db_comment='Whether the initiator confirmed the exchange', default=False)),
                ('receiver_confirmed', models.BooleanField(db_comment='Whether the receiver confirmed the exchange', default=False)),
                ('qr_scanned', models.BooleanField(db_comment='Whether the QR code was scanned during exchange', default=False)),
                ('notes', models.TextField(blank=True, db_comment='Additional notes about the exchange', null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True, db_comment='When the exchange record was created')),
                ('updated_at', models.DateTimeField(auto_now=True, db_comment='When the exchange record was last updated')),
                ('location', models.ForeignKey(blank=True, db_comment='Where the exchange took place', null=True, on_delete=django.db.models.deletion.SET_NULL, to='swaps.location')),
            ],
            options={
                'db_table': 'exchanges',
                'db_table_comment': 'Records of physical book exchanges between users',
            },
        ),
        migrations.CreateModel(
            name='Notification',
            fields=[
                ('notification_id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('type', models.CharField(choices=[('swap_proposed', 'Swap Proposed'), ('swap_accepted', 'Swap Accepted'), ('swap_confirmed', 'Swap Confirmed'), ('swap_completed', 'Swap Completed'), ('swap_cancelled', 'Swap Cancelled')], db_comment='Type of notification for UI and tracking', max_length=50)),
                ('message', models.TextField(db_comment='Notification message', validators=[django.core.validators.MaxValueValidator(500, message='Message must be 500 characters or less')])),
                ('is_read', models.BooleanField(db_comment='Tracks read/unread state', default=False)),
                ('is_archived', models.BooleanField(db_comment='Tracks archived state', default=False)),
                ('delivered_at', models.DateTimeField(blank=True, db_comment='Delivery timestamp for WebSocket diagnostics', null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True, db_comment='When notification was created')),
                ('book', models.ForeignKey(blank=True, db_comment='Book related to the notification (optional)', null=True, on_delete=django.db.models.deletion.SET_NULL, to='library.book')),
            ],
            options={
                'db_table': 'notifications',
                'db_table_comment': 'Sends alerts for swaps and other events',
            },
        ),
    ]
